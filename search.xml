<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Springboot配置memcache]]></title>
    <url>%2F2019%2F06%2F21%2FSpringboot%E9%85%8D%E7%BD%AEmemcache%2F</url>
    <content type="text"><![CDATA[Memcached 介绍Memcached 是一个高性能的分布式内存对象缓存系统，用于动态Web应用以减轻数据库负载。它通过在内存中缓存数据和对象来减少读取数据库的次数，从而提高动态、数据库驱动网站的速度。Memcached基于一个存储键/值对的hashmap。其守护进程（daemon ）是用C写的，但是客户端可以用任何语言来编写，并通过memcached协议与守护进程通信。 因为 Spring Boot 没有针对 Memcached 提供对应的组建包，因此需要我们自己来集成。官方推出的 Java 客户端 Spymemcached 是一个比较好的选择之一。 Spymemcached 介绍Spymemcached 最早由 Dustin Sallings 开发，Dustin 后来和别人一起创办了 Couchbase (原NorthScale)，职位为首席架构师。2014 加入 Google。 Spymemcached 是一个采用 Java 开发的异步、单线程的 Memcached 客户端， 使用 NIO 实现。Spymemcached 是 Memcached 的一个流行的 Java client 库，性能表现出色，广泛应用于 Java + Memcached 项目中。 依赖配置添加依赖 pomx 包中添加 spymemcached 的引用 12345&lt;dependency&gt; &lt;groupId&gt;net.spy&lt;/groupId&gt; &lt;artifactId&gt;spymemcached&lt;/artifactId&gt; &lt;version&gt;2.12.2&lt;/version&gt;&lt;/dependency&gt; 在项目resource-&gt;config-&gt;dev和pro中新增memcachedconf.properties， 这时需要使用@PropertySource注解加载指定的属性文件。 设置配置对象 创建 MemcacheSource 接收配置信息 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071package olaf.olaf.service;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.context.annotation.PropertySource;import org.springframework.stereotype.Component;@Component@ConfigurationProperties(prefix = &quot;memcached&quot;)@PropertySource(&quot;classpath:memcachedconf.properties&quot;)public class MemcacheSource &#123; private boolean isOpen; private String servers; private int expires; private int port; private int connectionPoolSize; private String pre; public String getPre() &#123; return pre; &#125; public void setPre(String pre) &#123; this.pre = pre; &#125; public boolean getIsOpen() &#123; return isOpen; &#125; public void setIsOpen(boolean open) &#123; isOpen = open; &#125; public String getServers() &#123; return servers; &#125; public void setServers(String servers) &#123; this.servers = servers; &#125; public int getExpires() &#123; return expires; &#125; public void setExpires(int expires) &#123; this.expires = expires; &#125; public int getPort() &#123; return port; &#125; public void setPort(int port) &#123; this.port = port; &#125; public int getConnectionPoolSize() &#123; return connectionPoolSize; &#125; public void setConnectionPoolSize(int connectionPoolSize) &#123; this.connectionPoolSize = connectionPoolSize; &#125;&#125; @ConfigurationProperties(prefix = &quot;memcache&quot;) 的意思会以 memcache.* 为开通将对应的配置文件加载到属性中。 启动初始化 MemcachedClientCommandLineRunner 接口的 Component 会在所有 Spring Beans都初始化之后，SpringApplication.run()之前执行，非常适合在应用程序启动之初进行一些数据初始化的工作。利用 CommandLineRunner 在项目启动的时候配置好 MemcachedClient 。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279package olaf.olaf.service;import net.spy.memcached.MemcachedClient;import org.apache.commons.logging.Log;import org.apache.commons.logging.LogFactory;import org.springframework.boot.CommandLineRunner;import org.springframework.stereotype.Component;import org.springframework.util.StringUtils;import javax.annotation.Resource;import java.io.IOException;import java.net.InetSocketAddress;import java.util.Collection;import java.util.Map;import java.util.concurrent.Future;import java.util.concurrent.TimeUnit;/** * Author: yuanhy * Time: 2017-9-6 17:04 * Description: */@Componentpublic class Memcached implements CommandLineRunner &#123; private static Log log = LogFactory.getLog(Memcached.class); private MemcachedClient mc; public final static int DEFAULT_TIMEOUT = 5; /** * The constant timeUnitSeconds. */ public final static TimeUnit timeUnitSeconds = TimeUnit.SECONDS; @Resource private MemcacheSource memcacheSource; /* set 无论何时都保存 */ public &lt;T&gt; void set(String key, T value) &#123; this.set(key, memcacheSource.getExpires(), value); &#125; /** * 设置键值对 * * @param key key * @param expires 单位:秒，0 表示永不过期 * @param value 必须是一个可序列化的对象, 可以是容器类型如:List，但容器里面保存的对象必须是可序列化的 */ public &lt;T&gt; void set(String key, int expires, T value) &#123; if (StringUtils.isEmpty(key)) &#123; return; &#125; try &#123; if (memcacheSource.getIsOpen() &amp;&amp; mc != null) &#123; Future&lt;Boolean&gt; rs = mc.set(memcacheSource.getPre() + key, expires, value); System.out.println(rs.get()); &#125; &#125; catch (Exception e) &#123; log.error(e.getMessage(), e); &#125; &#125; /** * 根据key获得值 * * @param key key * @return value */ public &lt;T&gt; T get(String key) &#123; try &#123; if (!StringUtils.isEmpty(key) &amp;&amp; memcacheSource.getIsOpen() &amp;&amp; mc != null) &#123; return (T) mc.get(memcacheSource.getPre()+ key); &#125; &#125; catch (Exception e) &#123; log.error(e.getMessage(), e); &#125; return null; &#125; /** * 将对象添加到缓存 * * @param key the key * @param value the value * @param expire the expire * @return the boolean */ public Boolean add(String key, Object value, int expire) &#123; Future&lt;Boolean&gt; f = mc.add(key, expire, value); return getResult(f); &#125; /** * 替换某个键值 * * @param key the 键 * @param value the 值 * @param expire the 过期时间 * @return the boolean */ public Boolean replace(String key, Object value, int expire) &#123; Future&lt;Boolean&gt; f = mc.replace(key, expire, value); return getResult(f); &#125; /** * 删除某个特定键 * * @param key the key * @return the boolean */ public Boolean delete(String key) &#123; Future&lt;Boolean&gt; f = mc.delete(key); return getResult(f); &#125; /** * 立即从所有服务器清除所有缓存,慎用。 * * @return the boolean */ @Deprecated public Boolean flush() &#123; Future&lt;Boolean&gt; f = mc.flush(); return getResult(f); &#125; /** * 从缓存中获取多个键值。 * * @param keys the 键集合 * @return the multi */ public Map&lt;String, Object&gt; getMulti(Collection&lt;String&gt; keys) &#123; return mc.getBulk(keys); &#125; /** * 从缓存中获取多个键值 * * @param keys the 键数组 * @return the multi */ public Map&lt;String, Object&gt; getMulti(String[] keys) &#123; return mc.getBulk(keys); &#125; /** * 异步地从缓存中获取一组对象并使用它们进行解码 * * @param keys the 键集合 * @return the map */ public Map&lt;String, Object&gt; asyncGetMulti(Collection&lt;String&gt; keys) &#123; Map&lt;String, Object&gt; map = null; Future&lt;Map&lt;String, Object&gt;&gt; f = mc.asyncGetBulk(keys); try &#123; map = getResult(f); &#125; catch (Exception e) &#123; f.cancel(false); &#125; return map; &#125; /** * 增加给定的计数器，返回新值。 * * @param key the key * @param by the 增值 * @param defaultValue the 默认值(如计时器不存在)，如该key没值，则取默认值 * @param expire the 过期时间 * @return the long */ public long increment(String key, int by, long defaultValue, int expire) &#123; return mc.incr(key, by, defaultValue, expire); &#125; /** * 以给定的数量增加给定的键。 * * @param key the key * @param by the 增值 * @return the long */ public long increment(String key, int by) &#123; return mc.incr(key, by); &#125; /** * 减量. * * @param key the key * @param by the 减量 * @param defaultValue the 默认值(如果计数器不存在) * @param expire the 过期时间 * @return the long */ public long decrement(String key, int by, long defaultValue, int expire) &#123; return mc.decr(key, by, defaultValue, expire); &#125; /** * 减量 * * @param key the key * @param by the 要减的值 * @return the long */ public long decrement(String key, int by) &#123; return mc.decr(key, by); &#125; /** * 异步增量，并返回当前值. * * @param key the key * @param by the 要增加的值 * @return the long */ public Long asyncIncrement(String key, int by) &#123; Future&lt;Long&gt; f = mc.asyncIncr(key, by); return getResult(f); &#125; /** * Async decrement long. * 异步减量，并返回当前值 * * @param key the key * @param by the 要减少的值 * @return the long */ public Long asyncDecrement(String key, int by) &#123; Future&lt;Long&gt; f = mc.asyncDecr(key, by); return getResult(f); &#125; /** * Gets result. * 获取返回结果 * * @param &lt;T&gt; the type parameter * @param future the future * @return the result */ public &lt;T&gt; T getResult(Future&lt;T&gt; future) &#123; try &#123; return future.get(DEFAULT_TIMEOUT, timeUnitSeconds); &#125; catch (Exception e) &#123; log.warn(&quot;获取返回结果失败!&#123;&#125;&quot;, e); &#125; return null; &#125; /** * 关闭连接 */ public void disConnect() &#123; if (mc == null) &#123; return; &#125; mc.shutdown(); &#125; @Override public void run(String... args) throws Exception &#123; System.out.println(&quot;The Runner start to initialize ...&quot;); try &#123; mc = new MemcachedClient(new InetSocketAddress(memcacheSource.getServers(),memcacheSource.getPort())); &#125; catch (IOException e) &#123; log.error(&quot;inint MemcachedClient failed &quot;,e); &#125; &#125;&#125; 测试使用12memcached.&lt;UserVo&gt;set(vo.getLoginName(), 43200, vo);UserVo vo = memcached.get(loginToken);]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter国际化设置在iOS设备上不生效的问题]]></title>
    <url>%2F2019%2F05%2F16%2FFlutter%E5%9B%BD%E9%99%85%E5%8C%96%E8%AE%BE%E7%BD%AE%E5%9C%A8iOS%E8%AE%BE%E5%A4%87%E4%B8%8A%E4%B8%8D%E7%94%9F%E6%95%88%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[参考官方资料，添加了中文国际化相关配置代码： class App extends StatelessWidget { // This widget is the root of your application. @override Widget build(BuildContext context) { return new MaterialApp( title: &apos;饭点&apos;, theme: new ThemeData( primarySwatch: Colors.blue, ), home: new MainPage(title: &apos;饭点&apos;), localizationsDelegates: [ GlobalMaterialLocalizations.delegate, GlobalWidgetsLocalizations.delegate, ], supportedLocales: [ const Locale(&apos;zh&apos;, &apos;CH&apos;), const Locale(&apos;en&apos;, &apos;US&apos;), ], ); } } 实际运行发现，即便设备已经设置了中文和中国地区，但iOS设备上依旧显示英文，Android设备就没有这个问题。 俺做iOS已经是6年前的事情了，现在可以说开发经验几乎归零了，摸索了一顿找到了解决方案。 使用Xcode打开ios项目： 然后再项目设置里添加一个中文的国际化配置： 然后在重新打包就可以了。]]></content>
      <categories>
        <category>flutter</category>
      </categories>
      <tags>
        <tag>flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[element UI实现动态生成多级表头]]></title>
    <url>%2F2019%2F05%2F05%2Felement-UI%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81%E7%94%9F%E6%88%90%E5%A4%9A%E7%BA%A7%E8%A1%A8%E5%A4%B4%2F</url>
    <content type="text"><![CDATA[一、效果图二、封装两个组件，分别为DynamicTable.vue和TableColumn.vue，TableColumn.vue主要是使用递归来对表头进行循环生成DynamicTable.vue 1 &lt;template&gt; 2 &lt;el-table :data=”tableData” border :height=”height”&gt; 3 &lt;template v-for=”item in tableHeader”&gt; 4 &lt;table-column v-if=”item.children &amp;&amp; item.children.length” :key=”item.id” :coloumn-header=”item”&gt;&lt;/table-column&gt; 5 &lt;el-table-column v-else :key=”item.id” :label=”item.label” :prop=”item.prop” align=”center”&gt;&lt;/el-table-column&gt; 6 &lt;/template&gt; 7 &lt;/el-table&gt; 8 &lt;/template&gt; 910 &lt;script&gt;11 import TableColumn from ‘./TableColumn’12 export default {13 props: {14 // 表格的数据15 tableData: {16 type: Array,17 required: true18 },19 // 多级表头的数据20 tableHeader: {21 type: Array,22 required: true23 },24 // 表格的高度25 height: {26 type: String,27 default: ‘300’28 }29 },30 components: {31 TableColumn32 }33 }34 &lt;/script&gt;3536 &lt;style scoped&gt;3738 &lt;/style&gt;; “复制代码”) TableColumn.vue &lt;template&gt; &lt;el-table-column :label="coloumnHeader.label" :prop="coloumnHeader.label" align="center"&gt; &lt;template v-for="item in coloumnHeader.children"&gt; &lt;tableColumn v-if="item.children &amp;&amp; item.children.length" :key="item.id" :coloumn-header="item"&gt;&lt;/tableColumn&gt; &lt;el-table-column v-else :key="item.name" :label="item.label" :prop="item.prop" align="center"&gt;&lt;/el-table-column&gt; &lt;/template&gt; &lt;/el-table-column&gt; &lt;/template&gt; &lt;script&gt; export default { name: 'tableColumn', props: { coloumnHeader: { type: Object, required: true } } } &lt;/script&gt; &lt;style scoped&gt; &lt;/style&gt; [![复制代码](//common.cnblogs.com/images/copycode.gif)](javascript:void(0); "复制代码") **三、使用** HTML代码 1 &lt;div class="result-wrapper"&gt; 2 &lt;dynamic-table :table-data="tableData" :table-header="tableConfig" v-if="dynamicTableShow"&gt;&lt;/dynamic-table&gt; 3 &lt;dynamic-form v-else&gt;&lt;/dynamic-form&gt; 4 &lt;/div&gt; JS代码 1 &lt;script&gt; 2 import DynamicTable from './components/DynamicTable' 3 export default { 4 components: { 5 DynamicTable 6 }, 7 data () { 8 return { 9 searchForm: { 10 month: getMonth(), 11 serviceCategory: '1' 12 }, 13 dynamicTableShow: true, // 使得DynamicTable组件重新渲染变量 14 // 表数据 15 tableData: [ 16 { 17 districtName: '1', 18 timeDimension: '2', 19 residentPopNum: '3', 20 residentPopDst: '4', 21 liveLandArea: '5', 22 liveLandDst: '6', 23 employmentLandArea: '7', 24 employmentLandDst: '8' 25 } 26 ], 27 // 表头数据 28 tableConfig: [ 29 { 30 id: 100, 31 label: '一级表头', 32 prop: '', 33 children: [ 34 { 35 id: 110, 36 label: '二级表头1', 37 prop: 'districtName' 38 }, 39 { 40 id: 120, 41 label: '二级表头2', 42 prop: 'timeDimension' 43 } 44 ] 45 }, 46 { 47 id: 200, 48 label: '一级表头1', 49 prop: '', 50 children: [ 51 { 52 id: 210, 53 label: '二级表头2', 54 prop: '', 55 children: [ 56 { 57 id: 211, 58 label: '三级表头3', 59 prop: 'residentPopNum' 60 }, 61 { 62 id: 212, 63 label: '三级表头', 64 prop: 'residentPopDst' 65 } 66 ] 67 } 68 ] 69 }, 70 { 71 id: 300, 72 label: '一级表头1', 73 prop: '', 74 children: [ 75 { 76 id: 310, 77 label: '二级表头2', 78 prop: '', 79 children: [ 80 { 81 id: 311, 82 label: '三级表头3', 83 prop: 'liveLandArea' 84 }, 85 { 86 id: 312, 87 label: '三级表头3', 88 prop: 'liveLandDst' 89 } 90 ] 91 }, 92 { 93 id: 320, 94 label: '二级表头1', 95 prop: '', 96 children: [ 97 { 98 id: 321, 99 label: '三级表头3', 100 prop: 'employmentLandArea' 101 }, 102 { 103 id: 322, 104 label: '三级表头3', 105 prop: 'employmentLandDst' 106 } 107 ] 108 } 109 ] 110 } 111 ] 112 } 113 }, 114 methods: { 115 // 服务类型改变的时候，需要重新请求表头信息和表格数据 116 handleServiceCategoryChange (val) { 117 // 设置dynamicTableShow为false，使得DynamicTable组件重新渲染 118 this.dynamicTableShow = false 119 if (val === '1') { 120 this.tableData = [ 121 { 122 districtName: '1', 123 timeDimension: '2', 124 residentPopNum: '3', 125 residentPopDst: '4', 126 liveLandArea: '5', 127 liveLandDst: '6', 128 employmentLandArea: '7', 129 employmentLandDst: '8' 130 } 131 ] 132 this.tableConfig = [ 133 { 134 id: 100, 135 label: '一级表头', 136 prop: '', 137 children: [ 138 { 139 id: 110, 140 label: '二级表头1', 141 prop: 'districtName' 142 }, 143 { 144 id: 120, 145 label: '二级表头2', 146 prop: 'timeDimension' 147 } 148 ] 149 }, 150 { 151 id: 200, 152 label: '一级表头1', 153 prop: '', 154 children: [ 155 { 156 id: 210, 157 label: '二级表头2', 158 prop: '', 159 children: [ 160 { 161 id: 211, 162 label: '三级表头3', 163 prop: 'residentPopNum' 164 }, 165 { 166 id: 212, 167 label: '三级表头', 168 prop: 'residentPopDst' 169 } 170 ] 171 } 172 ] 173 }, 174 { 175 id: 300, 176 label: '一级表头1', 177 prop: '', 178 children: [ 179 { 180 id: 310, 181 label: '二级表头2', 182 prop: '', 183 children: [ 184 { 185 id: 311, 186 label: '三级表头3', 187 prop: 'liveLandArea' 188 }, 189 { 190 id: 312, 191 label: '三级表头3', 192 prop: 'liveLandDst' 193 } 194 ] 195 }, 196 { 197 id: 320, 198 label: '二级表头1', 199 prop: '', 200 children: [ 201 { 202 id: 321, 203 label: '三级表头3', 204 prop: 'employmentLandArea' 205 }, 206 { 207 id: 322, 208 label: '三级表头3', 209 prop: 'employmentLandDst' 210 } 211 ] 212 } 213 ] 214 } 215 ] 216 } else { 217 this.tableData = [ 218 { 219 districtName: '111', 220 timeDimension: '222' 221 } 222 ] 223 this.tableConfig = [ 224 { 225 id: 100, 226 label: '一级表头', 227 prop: '', 228 children: [ 229 { 230 id: 110, 231 label: '二级表头1', 232 prop: 'districtName' 233 }, 234 { 235 id: 120, 236 label: '二级表头2', 237 prop: 'timeDimension' 238 } 239 ] 240 } 241 ] 242 } 243 // 此处是DOM还没有更新，此处的代码是必须的 244 this.$nextTick(() =&gt; { 245 // DOM 现在更新了 246 this.dynamicTableShow = true 247 }) 248 } 249 } 250 } 251 &lt;/script&gt; 252 253 &lt;style scoped&gt; 254 .policy-wrapper{ 255 margin-top: 10px; 256 } 257 .result-wrapper{ 258 margin-top: 22px; 259 } 260 &lt;/style&gt;]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flutter踩坑记录之IOS输入框长按报错]]></title>
    <url>%2F2019%2F03%2F08%2Fflutter%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95%E4%B9%8BIOS%E8%BE%93%E5%85%A5%E6%A1%86%E9%95%BF%E6%8C%89%E6%8A%A5%E9%94%99%2F</url>
    <content type="text"><![CDATA[开发过程中发现在国际化过程中ios输入框长按会报错 flutter: Another exception was thrown: NoSuchMethodError: The getter ‘pasteButtonLabel’ was called on null. 本篇说明解决方法: 1.首先在pubspec.yaml的dependencies下加入这个 flutter_localizations: sdk: flutter 如图： 2.然后在MaterialApp设置一下localizationsDelegates如图: 3.写一个类继承一下CupertinoLocalizations，在项目中 我这个类名叫ChineseCupertinoLocalizations(没错，就是localizationsDelegates中的第三个)，如图： 上次提到报错的原因就是因为cutButtonLabel，copyButtonLabel，pasteButtonLabel，selectAllButtonLabel 这几个按钮没有实现，所以继承CupertinoLocalizations一定要为这几个按钮赋值，这里是那种语言，那么，赋值就对应那种语言，同时要注意locale.languageCode也要填写，如果你是中文，那么locale.languageCode ==’zh’; 4.在ios工程中，在项目的info设置语言环境 添加 Localization native development region—&gt;china 添加一个Localizations 为array类型的，并且设置值为 Chinese (simplified) 效果图：（注意：请把手机环境调试成中文的语言环境） Android ios 效果图 github地址 https://github.com/hxxsocket/flutter_lg_demo]]></content>
      <categories>
        <category>flutter</category>
      </categories>
      <tags>
        <tag>flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo Admin Deploy踩坑记录]]></title>
    <url>%2F2019%2F03%2F01%2FHexo-Admin-Deploy%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[参考hexo-admin/issues 背景由于Windows的某种原因，依据网站的大部分教程，均会抛出deploy Error: spawn UNKNOWN异常。而GitHub上issues给出了相关解决方案，现在总结一下具体的过程 填坑 打开站点配置文件(\xxxx.github.io\_config.yml)，在admin中加入deployCommand: &amp;#39;sh hexo-deploy.sh&amp;#39;。示例： 12345admin: username: 看不见 password_hash: 看不见 secret: 看不见 deployCommand: &apos;sh hexo-deploy.sh&apos; 在根目录中(\xxxx.github.io\)新建hexo-deploy.sh文件，内容为： 1hexo g -d 打开deploy.js(\xxxx.github.io\node_modules\hexo-admin\deploy.js)，将var proc = spawn(command, [message], {detached: true});更改为var proc = spawn((process.platform === &amp;quot;win32&amp;quot; ? &amp;quot;hexo.cmd&amp;quot; : &amp;quot;hexo&amp;quot;), [&amp;#39;d&amp;#39;, &amp;#39;-g&amp;#39;]);更改完后的代码： 1234567891011121314module.exports = function (command, message, done) &#123; done = once(done); var proc = spawn((process.platform === &quot;win32&quot; ? &quot;hexo.cmd&quot; : &quot;hexo&quot;), [&apos;d&apos;, &apos;-g&apos;]); var stdout = &apos;&apos;; var stderr = &apos;&apos;; proc.stdout.on(&apos;data&apos;, function(data)&#123;stdout += data.toString()&#125;) proc.stderr.on(&apos;data&apos;, function(data)&#123;stderr += data.toString()&#125;) proc.on(&apos;error&apos;, function(err) &#123; done(err, &#123;stdout: stdout, stderr: stderr&#125;); &#125;); proc.on(&apos;close&apos;, function () &#123; done(null, &#123;stdout: stdout, stderr: stderr&#125;); &#125;);&#125; 效果]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo admin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git 常用命令(含删除文件)]]></title>
    <url>%2F2019%2F03%2F01%2F%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[0.可以通过git branch -r 命令查看远端库的分支情况 &nbsp; 1,从已有的分支创建新的分支(如从master分支),创建一个dev分支 git checkout -b dev 2,创建完可以查看一下,分支已经切换到dev git branch &nbsp;&nbsp;&nbsp;&nbsp;* dev &nbsp;&nbsp;&nbsp;&nbsp;master 3.建立本地到上游（远端）仓的链接 –这样代码才能提交上去 git branch –set-upstream-to=origin/dev&nbsp; 取消对master的跟踪 git branch –unset-upstream master &nbsp; git 创建分支提交远程分支 - oppotvrhttps://my.oschina.net/u/219482/blog/285584 &nbsp; 以下两个应该是同一个意思，=upstream : 上游码流的意思git branch –set-upstream-to=mastergit branch –set-upstream-to=original/master git help branchgit branch [–set-upstream | –track | –no-track] [-l] [-f] &lt;branchname&gt; [&lt;start-point&gt;]git branch (–set-upstream-to=&lt;upstream&gt; | -u &lt;upstream&gt;) [&lt;branchname&gt;]git branch –unset-upstream [&lt;branchname&gt;] git branch –set-upstream-to=original/master newgit branch –set-upstream debug origin/debug //其中debug为创建的分支 &nbsp; 提交该分支到远程仓库git push origin dev git push origin与git push -u origin master的区别&nbsp; $ git push origin 上面命令表示，将当前分支推送到origin主机的对应分支。&nbsp; 如果当前分支只有一个追踪分支，那么主机名都可以省略。&nbsp; $ git push 如果当前分支与多个主机存在追踪关系，那么这个时候-u选项会指定一个默认主机，这样后面就可以不加任何参数使用git push。 $ git push -u origin master 上面命令将本地的master分支推送到origin主机，同时指定origin为默认主机，后面就可以不加任何参数使用git push了。 本地分支代码提交到远端库git push origin mastergit push origin HEAD:refs/for/远端分支名 git push origin 本地分支名:refs/for/远端分支名 eg:git push origin test:refs/for/master #本地test分支代码提交到远端master库 在远端服务器新建分支： 方法1： git checkout -b dev #建立本地到上游（远端）仓的链接 –这样代码才能提交上去git branch –set-upstream-to=origin/devgit branch –set-upstream debug origin/debug //其中debug为创建的分支git push origin dev #取消对master的跟踪git branch –unset-upstream master &nbsp; 方法2： git branch -b stage2git push origin 本地分支名:远端分支名xx&nbsp; // 在服務器新建新分支名xxx &nbsp; 对比： git branch -b stag2git push origin stage2:refs/for/stage2 // 代码入庫命令，不会新建新分支在远端]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[欢迎！]]></title>
    <url>%2F2019%2F02%2F22%2Fhello-world%2F</url>
    <content type="text"><![CDATA[欢迎来到我的博客，我是程序员张翔宇我来自江苏镇江，请多多指教！]]></content>
  </entry>
</search>
